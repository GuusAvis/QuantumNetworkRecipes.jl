"""
    EntangledStateType

Type of entangled state that is generated upon success of heralded entanglement generation.

The type of entanglement that is generated along a quantum-network edge can be
parameterized using a composite type that is a subtype of `EntangledStateType`.
This can be used to tune the state model separately for edge/network recipes
(e.g., to see whether different results are obtained using a simplified Werner model versus
a more physically motivated model), and to allow code reuse between different recipes that
use the same state model.
"""
abstract type EntangledStateType end

"""
    WernerState

Werner states are mixtures between a Bell state and the maximally mixed state.

More precisely, a Werner state with Werner parameter ``p`` is given by
``ρ_p = p  \\ketbra{Φ^+}  + (1 - p) \\mathbb 1 / 4``,
where ``\\ket{Φ^+} = \\tfrac 1 {\\sqrt 2} (\\ket{00} + \\ket{11})`` is the Bell state
and ``\\mathbb 1 / 4``` is the maximally mixed state.
It has fidelity ``F(ρ_p, Φ^+) = (1 + 3p) / 4``.
"""
struct WernerState <: EntangledStateType end

"""
    werner_parameter_from_fidelity(fidelity)

Obtain the Werner parameter of a Werner state with fidelity `fidelity`.
"""
werner_parameter_from_fidelity(fidelity) = (4 * fidelity - 1) / 3

"""
    fidelity_from_werner_parameter(werner_parameter)
    fidelity_from_werner_parameter(werner_parameter, werner_parameter_error)

Obtain the fidelity of a Werner state with Werner parameter `werner_parameter`.

If the error in the Werner parameter is given, the error in the fidelity is also returned.
"""
fidelity_from_werner_parameter(werner_parameter) = (1 + 3 * werner_parameter) / 4
fidelity_from_werner_parameter(werner_parameter, werner_parameter_error) = 
    fidelity_from_werner_parameter(werner_parameter), 3 / 4 * werner_parameter_error

"""
    RState

R states are mixtures between a Bell state and a separable state that is orthogonal to it.

More precisely, R states are of the form
``ρ_p = p  \\ketbra{Φ^+}  + (1 - p) \\ketbra{11}``,
where ``\\ket{Φ^+} = \\tfrac 1 {\\sqrt 2} (\\ket{00} + \\ket{11})`` is the Bell state.
It has fidelity ``F(ρ_p, Φ^+) = p``.
"""
struct RState <: EntangledStateType end

include("heralded_entanglement.jl")

struct SimpleHeraldedPhysical{S, T, U, V} <: EdgePhysicalRepresentation
    edge_length::S
    success_probability::T
    attempt_duration::U
    fidelity::V
end
edge_length(x::SimpleHeraldedPhysical) = x.edge_length

struct SimpleHeraldedRecipe{T<:EntangledStateType} <:
       HeraldedEntanglement{SimpleHeraldedPhysical, T}
    physical_edge::SimpleHeraldedPhysical
end
physical_representation(x::SimpleHeraldedRecipe) = x.physical_edge
success_probability(x::SimpleHeraldedRecipe,
    ::Tuple{SimpleNode{N},SimpleNode{N}}) where N<:Union{PerfectNode, NodeWithMemory} =
    physical_representation(x).success_probability
attempt_duration(x::SimpleHeraldedRecipe,
    ::Tuple{SimpleNode{N},SimpleNode{N}}) where N<:Union{PerfectNode, NodeWithMemory} =
    physical_representation(x).attempt_duration
entangled_state_fidelity(x::SimpleHeraldedRecipe,
    ::Tuple{SimpleNode{N},SimpleNode{N}}) where N<:Union{PerfectNode, NodeWithMemory} =
    physical_representation(x).fidelity

include("fiber.jl")

"""
    DirectTransmissionOverFiber

Heralded entanglement generation by transmitting entangled photons through fiber.

A photon that is entangled to a local particle is generated by one of the two nodes,
and then transmitted to the other node through a fiber segment.
At the other node, detection of the photon heralds the generation of entanglement between
a local particle at that node and the local particle at the source node.

It is assumed that the node that sends the photon is the node with the highest
`emission_efficiency`.
"""
struct DirectTransmissionOverFiber{T<:EntangledStateType} <:
       HeraldedEntanglement{FiberSegment, T}
    physical_edge::FiberSegment
    fidelity::Real
end
physical_representation(x::DirectTransmissionOverFiber) = x.physical_edge
num_multiplexing_modes(edge::DirectTransmissionOverFiber,
        ::Tuple{SimpleNode{N}, SimpleNode{N}}) where N<:Union{PerfectNode, NodeWithMemory} =
    num_multiplexing_modes(edge)
function num_multiplexing_modes(edge::DirectTransmissionOverFiber,
        nodes::Tuple{SimpleNode{N}, SimpleNode{N}}) where N<:AbstractNodeWithPhotonSource
    sending_node = argmax(emission_efficiency, nodes)
    min(num_multiplexing_modes(sending_node), num_multiplexing_modes(edge))
end

success_probability(edge::DirectTransmissionOverFiber,
        ::Tuple{SimpleNode{N},SimpleNode{N}}) where
        N <: Union{PerfectNode, NodeWithMemory} =
    success_probability_with_multiplexing(edge_efficiency(edge),
        num_multiplexing_modes(edge))
function success_probability(edge::DirectTransmissionOverFiber,
        nodes::Tuple{SimpleNode{N}, SimpleNode{N}}) where N<:AbstractNodeWithPhotonSource
    efficiency_sending_node = maximum(emission_efficiency.(nodes))
    efficiency = edge_efficiency(edge) * efficiency_sending_node
    success_probability_with_multiplexing(efficiency, num_multiplexing_modes(edge, nodes))
end
attempt_duration(edge::DirectTransmissionOverFiber,
        ::Tuple{SimpleNode{N}, SimpleNode{N}}) where
        N <: Union{PerfectNode, NodeWithMemory} =
    2 * edge_length(edge) / speed_of_light_in_fiber
function attempt_duration(edge::DirectTransmissionOverFiber,
        nodes::Tuple{SimpleNode{N}, SimpleNode{N}}) where N<:AbstractNodeWithPhotonSource
    transmission_time = 2 * edge_length(edge) / speed_of_light_in_fiber
    sending_node = argmax(emission_efficiency, nodes)
    max(cycle_time(sending_node), transmission_time)
end
entangled_state_fidelity(edge::DirectTransmissionOverFiber,
        ::Tuple{SimpleNode{N}, SimpleNode{N}}) where
        N <: Union{PerfectNode, NodeWithMemory, NodeWithPhotonSource} =
    edge.fidelity

"""Entanglement generation by sending photons to a midpoint station.

Typically this may be done over fiber, but it could also be done over free space.
"""
abstract type MidHeraldedDetection{T<:EdgePhysicalRepresentation, S<:EntangledStateType} <:
    HeraldedEntanglement{T, S} end

num_multiplexing_modes(edge::MidHeraldedDetection{E, S},
        ::Tuple{SimpleNode{N}, SimpleNode{N}}) where
        {E<:FiberBasedEdge, N<:Union{PerfectNode, NodeWithMemory}, S<:EntangledStateType} =
    num_multiplexing_modes(edge)
function num_multiplexing_modes(edge::MidHeraldedDetection{E, S},
        nodes::Tuple{SimpleNode{N}, SimpleNode{N}}) where
        {E<:FiberBasedEdge, N<:AbstractNodeWithPhotonSource, S<:EntangledStateType}
    edge_num_modes = num_multiplexing_modes(physical_representation(edge))
    nodes_num_modes = minimum(num_multiplexing_modes.(nodes))
    min(edge_num_modes, nodes_num_modes)
end
attempt_duration(edge::MidHeraldedDetection{E, S},
        ::Tuple{SimpleNode{N}, SimpleNode{N}}) where
        {E<:FiberBasedEdge, N<:Union{PerfectNode, NodeWithMemory}, S<:EntangledStateType} =
    edge_length(edge) / speed_of_light_in_fiber
function attempt_duration(edge::MidHeraldedDetection{E, S},
        nodes::Tuple{SimpleNode{N}, SimpleNode{N}}) where
        {E<:FiberBasedEdge, N<:AbstractNodeWithPhotonSource, S<:EntangledStateType}
    transmission_time = edge_length(edge) / speed_of_light_in_fiber
    max(cycle_time.(nodes)..., transmission_time)
end

include("single_click_heralded_entanglement.jl")